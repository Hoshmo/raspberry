var colors = require('colors');
var net = require('net');
var Joystick = require("joystick-logitech-f710");

//var usonic = require('r-pi-usonic');
//var sensor = usonic.createSensor(GPIO.ULTRASONIC_IN, GPIO.ULTRASONIC_OUT, 650);

/** The following setting were tested using raw potentiometer (adjustable resistor knobs) as joystick **/
//var X_CENTER = 510;
//var Y_CENTER = 516;
//var THRESHOLD_LOW = 500;
//var THRESHOLD_HIGH = 520;
//var joyX = X_CENTER;
//var joyY = Y_CENTER;

/** The following setting were tested using the Logitech 710 joystick **/
var X_CENTER = 510;
var Y_CENTER = 516;
var THRESHOLD_LOW = 490;
var THRESHOLD_HIGH = 540;
var joyX = X_CENTER;
var joyY = Y_CENTER;

var HOST = 'localhost';
var PORT = 5432;
var SERVER_CONNECT = 1;
var MAX_JOYSTICK = 1017;
var MODE = 'XINPUT'; // XINPUT or DIRECT_INPUT switch button
var POLL_INTERVAL = 25;
var GPIO = {};
var SERVO_CENTER = 50;
var TOTAL_SERVOS = 16;

GPIO.ULTRASONIC_IN = 23;
GPIO.ULTRASONIC_OUT = 22;

/**
 noderob
 @method noderob
 @return {Object} noderob instance
 **/
exports.create = function (i_config) {
    return new noderob(i_config);
};

function noderob(i_config) {
    var self = this;
    self.m_debug = i_config.debug;
    self.m_serverConnect = i_config.serverConnect;
    self.m_leftMotor = 0;
    self.m_rightMotor = 0;
    self.m_direction = 'none';
    self.m_sharpTurn = 0;

    this._init();
}

noderob.prototype = {
    constructor: noderob,

    _init: function () {
        var self = this;
    },

    initServos: function () {
        var self = this;
        for (var i = 0; i < TOTAL_SERVOS; i++) {
            var s = 'self.m_servo' + i + ' = SERVO_CENTER';
            eval(s);
        }
    },

    log: function (i_msg, i_level, i_color) {
        if (!i_color)
            i_color = 'yellow';
        var self = this;
        if (self.m_debug >= i_level) {
            console.log(i_msg[i_color])
        }
    },

    startServerPolling: function () {
        var self = this;
        self.m_pollinghandle = setInterval(function () {
            //self.log('x ' + joyX + ' y ' + joyY, 1, 'white');
            //log('x ' + joyX + ' y ' + joyY, 1);
            self.controlDifferentialMotors();
            self._sendData();
        }, POLL_INTERVAL);
    },

    _sendData: function () {
        var self = this;
        // construct motor json data
        var jData = {
            leftMotor: self.m_leftMotor,
            rightMotor: self.m_rightMotor,
            direction: self.m_direction
        };

        // construct current servos json data
        for (var i = 0; i < TOTAL_SERVOS; i++) {
            var s = 'servo' + i;
            jData[s] = eval('self.m_servo' + i);
            //eval(s);
        }

        console.log(JSON.stringify(jData), 1);
        self.log(JSON.stringify(jData), 1, 'yellow');

        // send data to python server
        if (SERVER_CONNECT)
            self.m_socket.write(JSON.stringify(jData));
    },

    _driveMotors: function (leftMotor, rightMotor, direction) {
        var self = this;

        if (direction == 'sharpLeft' || direction == 'sharpRight'){
            self.m_leftMotor = 255;
            self.m_rightMotor = 255;
            self.m_direction = direction;
        }

        if (self.m_sharpTurn)
            return;

        leftMotor = Math.abs(self._fixDec(leftMotor));
        rightMotor = Math.abs(self._fixDec(rightMotor));

        // if motor is very low, might as well reset to avoid noise
        leftMotor = leftMotor < 0.2 ? 0 : leftMotor;
        rightMotor = rightMotor < 0.2 ? 0 : rightMotor;

        // convert 0 (low) to 0.99 (high) into 0 - 255 for motor speed
        self.m_leftMotor = Math.round(self._perc(leftMotor, 255) * 100);
        self.m_rightMotor = Math.round(self._perc(rightMotor, 255) * 100);

        self.m_direction = direction;

        // console.log(leftMotor, rightMotor, direction);
    },

    controlDifferentialMotors: function () {
        var self = this;
        var moveY, leftMotor, rightMotor, reduceX, reducePerc;
        var x = joyX;
        var y = joyY;
        var direction = 'none';

        moveY = leftMotor = rightMotor = (Y_CENTER - y) / Y_CENTER;

        if (rightMotor == 1 && leftMotor == 1)
            return;

        //log(rightMotor + ' -- ' + leftMotor, 1);
        self.log(rightMotor + ' -- ' + leftMotor, 1, 'yellow');

        /**
         sharp turn: enable following lines if you wish to mix
         to stick sharp extreme left and right
         to allow sharp turns via reverse differential: untested
         **/
        // if (y > THRESHOLD_LOW && y < THRESHOLD_HIGH) {
        //    if (x < THRESHOLD_LOW) {
        //        runMotor(1, 1, 'sharpLeft');
        //        return;
        //    }
        //    if (x > THRESHOLD_HIGH) {
        //        runMotor(1, 1, 'sharpRight');
        //        return
        //    }
        // }

        /** FORWARD **/
        if (moveY > 0) {
            direction = 'fwd';
            // left
            if (x < THRESHOLD_LOW) {
                reduceX = X_CENTER - x;
                reducePerc = (reduceX / X_CENTER) * 100;
                leftMotor = leftMotor - self._perc(leftMotor, reducePerc);
            }
            // right
            if (x > THRESHOLD_HIGH) {
                reduceX = X_CENTER - x;
                reducePerc = (reduceX / X_CENTER) * 100;
                rightMotor = rightMotor + self._perc(rightMotor, reducePerc);
            }
        }

        /** BACK **/
        if (moveY < 0) {
            direction = 'back';

            /** LEFT **/
            if (x < THRESHOLD_LOW) {
                reduceX = X_CENTER - x;
                reducePerc = (reduceX / X_CENTER) * 100;
                leftMotor = Math.abs(leftMotor) + self._perc(leftMotor, reducePerc);
            }
            /** RIGHT **/
            if (x > THRESHOLD_HIGH) {
                reduceX = X_CENTER - x;
                reducePerc = (reduceX / X_CENTER) * 100;
                rightMotor = Math.abs(rightMotor) - self._perc(rightMotor, reducePerc);
            }
        }
        self._driveMotors(leftMotor, rightMotor, direction);
    },

    initJoystick: function (i_mode) {
        var self = this;
        Joystick.create("/dev/input/js0", function (err, joystick) {
            if (err)
                throw err;

            /** cross **/

            joystick.on("button:crossup:press", function () {
                //log("A button:crossup:press", 3);
                self.m_servo2 = 100;
            });
            joystick.on("button:crossup:press:up", function () {
                //log("B button:crossup:press:up", 3);
                self.m_servo2 = 0;
            });
            joystick.on("button:crossdown:press", function () {
                //log("C button:crossdown:press", 3);
            });
            joystick.on("button:crossdown:press:up", function () {
                //log("D button:crossdown:press:up", 3);
            });
            joystick.on("button:crossleft:press", function () {
                //log("E button:crossleft:press", 3);
            });
            joystick.on("button:crossleft:press:up", function () {
                //log("F button:crossleft:press:up", 3);
            });
            joystick.on("button:crossright:press", function () {
                //log("G button:crossright:press", 3);
            });
            joystick.on("button:crossright:press:up", function () {
                //log("H button:crossright:press:up", 3);
            });
            joystick.setMaximumAxesPosition(MAX_JOYSTICK);

            joystick.on("button:a:press", function () {
                //log("a1", 3);
            });
            joystick.on("button:a:release", function () {
                //log("a2", 3);
            });
            joystick.on("button:a:release", function () {
                //log("a2", 3);
            });
            joystick.on("button:a:release", function () {
                //log("a2", 3);
            });
            joystick.on("stick:1:vertical:up", function (position) {
                //log("1: " + position, 3);
            });
            joystick.on("stick:1:vertical:down", function (position) {
                //log("2: " + position, 3);
            });
            joystick.on("stick:1:vertical:zero", function (position) {
                //log("3: " + position, 3);
            });
            joystick.on("stick:2:vertical:up", function (position) {
                self.m_servo1 = Math.round(position / 10) + 50;
                //log("7: " + position + ' ' + servo1);
            });
            joystick.on("stick:2:vertical:down", function (position) {
                self.m_servo1 = SERVO_CENTER - Math.round(position / 10);
                if (self.m_servo1 < 1)
                    self.m_servo1 = 0;
                //log("8: " + position + ' ' + servo0);
            });
            joystick.on("stick:2:vertical:zero", function (position) {
                //log("9: " + position, 3);
            });
            joystick.on("stick:2:horizontal:right", function (position) {
                self.m_servo0 = SERVO_CENTER - Math.round(position / 10);
                if (self.m_servo0 < 1)
                    self.m_servo0 = 0;
                //log("10: postion" + position + ' servo ' + servo0);
            });
            joystick.on("stick:2:horizontal:left", function (position) {
                self.m_servo0 = Math.round(position / 10) + 50;
                //log("11: position " + position + ' servo ' + servo0);
            });
            joystick.on("stick:2:horizontal:zero", function (position) {
                //log("12: " + position, 3);
            });
            joystick.on("stick:3:horizontal:right", function (position) {
                //log("16: " + position, 3);
            });
            joystick.on("stick:3:horizontal:left", function (position) {
                //log("17: " + position, 3);
            });
            joystick.on("stick:3:horizontal:zero", function (position) {
                //log("18: " + position, 3);
            });
            joystick.on("stick:1:horizontal:right", function (position) {
                joyY = Math.abs((position / 2) + Y_CENTER);
                //log("STICK DOWN: " + position + ' joyY: ' + joyY, 3);
            });
            joystick.on("stick:1:horizontal:left", function (position) {
                joyY = Math.abs((position / 2) - Y_CENTER);
                //log("STICK UP: " + position + ' joyY: ' + joyY, 3);
            });
            joystick.on("stick:3:vertical:up", function (position) {
                joyX = Math.abs((position / 2) - X_CENTER);
                //log("STICK LEFT: " + position + ' joyX: ' + joyX, 3);
            });
            joystick.on("stick:3:vertical:down", function (position) {
                joyX = Math.abs((position / 2) + X_CENTER);
                //log("STICK RIGHT: " + position + ' joyX: ' + joyX, 3);
            });
            joystick.on("stick:1:horizontal:right", function (position) {
                joyY = Math.abs((position / 2) + Y_CENTER);
                //log("STICK DOWN: " + position + ' joyY: ' + joyY, 3);
            });
            joystick.on("stick:1:horizontal:left", function (position) {
                joyY = Math.abs((position / 2) - Y_CENTER);
                //log("STICK UP: " + position + ' joyY: ' + joyY, 3);
            });
            joystick.on("stick:3:vertical:up", function (position) {
                joyX = Math.abs((position / 2) - X_CENTER);
                //log("STICK LEFT: " + position + ' joyX: ' + joyX, 3);
            });
            joystick.on("stick:3:vertical:down", function (position) {
                joyX = Math.abs((position / 2) + X_CENTER);
                //log("STICK RIGHT: " + position + ' joyX: ' + joyX, 3);
            });
            joystick.on("stick:3:vertical:zero", function (position) {
                //log("A: " + position, 3);
            });
            joystick.on("stick:1:horizontal:zero", function (position) {
                //log("B: " + position, 3);
            });

            /** Motor controls **/
            joystick.on("button:lb:press", function () {
                self.m_sharpTurn = 1;
                self._driveMotors(1, 1, 'sharpLeft');
            });
            joystick.on("button:lb:release", function () {
                self.m_sharpTurn = 0;
                self._driveMotors(0, 0, 'fwd');
            });
            joystick.on("button:rb:press", function () {
                self.m_sharpTurn = 1;
                self._driveMotors(1, 1, 'sharpRight');
            });
            joystick.on("button:rb:release", function () {
                self.m_sharpTurn = 0;
                self._driveMotors(0, 0, 'fwd');
            });
            joystick.on("button:ls:press", function () {
                //log("stop", 2);
                self._driveMotors(0, 0, 'fwd');
            });
            joystick.on("button:ls:release", function () {
                //log("stop", 2);
                self._driveMotors(0, 0, 'fwd');
            });
        });
    },

    _joystickMotorInit: function () {
        var self = this;
    },

    _joystickCrossInit: function () {
        var self = this;
    },

    /**
     Connect to python socket server
     @method initSocket
     **/
    initSocket: function () {
        var self = this;
        if (self.m_serverConnect) {
            self.m_socket = new net.Socket();
            self.m_socket.connect(PORT, HOST, function () {
                self.log('Robot client connected', 0);
            });

            // this event handler is called when data is received on the socket
            self.m_socket.on('data', function (data) {
                //log('DATA: ' + data);
            });

            // if the socket is closed, this handler will be called
            self.m_socket.on('close', function () {
                self.log('Connection closed', 0);
            });

            // catch cont-c
            //process.on('SIGINT', function(){
            //    socket.destroy();
            //    process.exit();
            //});

            return self.m_socket;
        }
    },

    /**
     Get percent
     @method _perc
     @param {Number} _perc
     @param {Number} amount
     @return {Number}
     **/
    _perc: function (num, amount) {
        return num * amount / 100;
    },

    /**
     Fix string / numeric to decimal
     @method _fixDec
     @param {Number} val
     @return {Number}
     **/
    _fixDec: function (val) {
        return parseFloat(val).toFixed(2)
    }

};
