/**

 NodeRob.js
 ==========
 In this module we mostly bind to the selected device, either directly such as in the case of the Logitech
 joystick or indirectly through the python server for I2C devices (LCD, Motor Servo HATs) on both input and output.

 Once we bind to a particular device (initSocket, initServos, initJoystick etc...) we are able to
 tx and rx GPIO or I2C commands to interact with the device.

 Generic binding as well as basic algorithm is managed in this module. For example, motor control for differential
 robot movement is managed in this module. However, any specific utility logic should be managed from the instantiating app.
 **/
var colors = require('colors');
var net = require('net');
var util = require('util');
var piblaster = require('pi-blaster.js');
var EventEmitter = require('events').EventEmitter;
var Gpio = require('onoff').Gpio;
var wpi = require('wiring-pi');
var lcd;

//var usonic = require('r-pi-usonic');
//var sensor = usonic.createSensor(GPIO.ULTRASONIC_IN, GPIO.ULTRASONIC_OUT, 650);

var SERVO_MODE = 'ADAHAT'; // SERVOBLASTER | ADAHAT
var THRESHOLD_LOW = -5;
var THRESHOLD_HIGH = 5;
var MAX_JOYSTICK = 100;
var SERVO_CENTER_HAT = 50; // reverse 25 100% | center 50 0% | forward 75 100%
var SERVO_CENTER_BLASTER = 0.13; // reverse 0.11 100% | center 0.13 0% | forward 0.15 100%
var TOTAL_SERVOS = 14;
var joyX = 0;
var joyY = 0;

var GPIO = {};
GPIO.ULTRASONIC_IN = 23;
GPIO.ULTRASONIC_OUT = 22;

var NodeRob = function (i_config) {
    var self = this;
    EventEmitter.call(self);

    self.m_debug = i_config.debug;
    self.m_serverConnect = i_config.serverConnect;
    self.m_port = i_config.port;
    self.m_host = i_config.host;
    self.m_pollInterval = i_config.pollInterval
    self.m_leftMotor = 0;
    self.m_rightMotor = 0;
    self.m_direction = 'none';
    // self.m_sharpTurn = 0;
    self.m_model = -1;
    this._init();

};

util.inherits(NodeRob, EventEmitter);

NodeRob.prototype._init = function () {
    var self = this;
};

NodeRob.prototype._sendData = function () {
    var self = this;
    // construct motor json data
    var jData = {
        leftMotor: self.m_leftMotor,
        rightMotor: self.m_rightMotor,
        direction: self.m_direction,
    };

    // construct current servos json data
    for (var i = 0; i < TOTAL_SERVOS; i++) {
        var s = 'servo' + i;
        jData[s] = eval('self.m_servo' + i);
    }

    self.log(JSON.stringify(jData), 1, 'yellow');

    if (self.m_socket)
        self.m_socket.write(JSON.stringify(jData));
};

NodeRob.prototype._perc = function (num, amount) {
    return num * amount / 100;
};

NodeRob.prototype._fixDec = function (val) {
    return parseFloat(val).toFixed(2)
};

NodeRob.prototype._differentialMotors = function () {
    var self = this;
    var reduceX;
    var sharp = false;
    self.m_leftMotor = self.m_rightMotor = joyY;

    /** sharp turn **/
    if (joyY > (THRESHOLD_LOW * 3) && joyY < (THRESHOLD_HIGH * 3)) {
        if (joyX > 85) {
            sharp = true;
            joyX = 100;
            self.m_leftMotor = -100;
            self.m_rightMotor = 100;
        }
        if (joyX < -85) {
            sharp = true;
            self.m_leftMotor = 100;
            self.m_rightMotor = -100;
        }
    }

    /** not in sharp turn **/
    if (!sharp) {

        /** FORWARD **/
        if (joyY > 0) {
            // left
            reduceX = self._perc(joyY, joyX);
            if (joyX > THRESHOLD_HIGH)
                self.m_leftMotor = self.m_leftMotor - reduceX;
            // right
            if (joyX < THRESHOLD_LOW)
                self.m_rightMotor = (self.m_rightMotor - (reduceX * -1));
        }

        /** BACK **/
        if (joyY < 0) {
            /** LEFT **/
            reduceX = self._perc(joyY, joyX);
            if (joyX > THRESHOLD_HIGH)
                self.m_leftMotor = self.m_leftMotor - reduceX;
            // right
            if (joyX < THRESHOLD_LOW)
                self.m_rightMotor = self.m_rightMotor - (reduceX * -1);
        }
    }

    // At this point the differential for each motor is all set properly in values
    // ranging from -100 to 100 per leftMotor and rightMotor.
    // the following section modifies the values to accommodate each platform's ratios
    // such as Adafruit HAT, ServoBlaster and more can be added (i.e. Joystick potentiometer)

    switch (SERVO_MODE) {

        case 'ADAHAT':
        {

            /**************************************
             *
             * Adafruit Servo HAT - Python server
             *
             **************************************/


            /** moving fwd **/
            if (self.m_leftMotor >= 0 && self.m_rightMotor >= 0) {
                self.m_leftMotor = (self.m_leftMotor * 0.25) + SERVO_CENTER_HAT;
                self.m_rightMotor = (self.m_rightMotor * 0.25) + SERVO_CENTER_HAT;
            }

            /** moving back **/
            if (self.m_leftMotor <= 0 && self.m_rightMotor <= 0) {
                self.m_leftMotor = SERVO_CENTER_HAT + self.m_leftMotor * 0.25;
                self.m_rightMotor = SERVO_CENTER_HAT + self.m_rightMotor * 0.25;
            }

            /** sharp left **/
            if (self.m_leftMotor == 100 && self.m_rightMotor == -100) {
                self.m_leftMotor = 75;
                self.m_rightMotor = 25;
            }

            /** sharp right **/
            if (self.m_leftMotor == -100 && self.m_rightMotor == 100) {
                self.m_leftMotor = 25;
                self.m_rightMotor = 75;
            }

            self.m_leftMotor = Math.round(self.m_leftMotor);
            self.m_rightMotor = Math.round(self.m_rightMotor);
            break;
        }

        case 'SERVOBLASTER':
        {

            /**************************************
             *
             * SERVO BLASTER - DIRECT
             *
             **************************************/

            var precision = 0.05;
            var low = 0.10;
            var high = 0.18;

            /** moving fwd **/
            if (self.m_leftMotor >= 0 && self.m_rightMotor >= 0) {
                self.m_leftMotor = ((self.m_leftMotor * precision) / 100) + SERVO_CENTER_BLASTER;
                self.m_rightMotor = ((self.m_rightMotor * precision) / 100) + SERVO_CENTER_BLASTER;
            }

            /** moving back **/
            if (self.m_leftMotor <= 0 && self.m_rightMotor <= 0) {
                self.m_leftMotor = SERVO_CENTER_BLASTER + ((self.m_leftMotor * precision) / 100);
                self.m_rightMotor = SERVO_CENTER_BLASTER + ((self.m_leftMotor * precision) / 100);
            }

            /** sharp left **/
            if (self.m_leftMotor == 100 && self.m_rightMotor == -100) {
                self.m_leftMotor = high;
                self.m_rightMotor = low;
            }

            /** sharp right **/
            if (self.m_leftMotor == -100 && self.m_rightMotor == 100) {
                self.m_leftMotor = low;
                self.m_rightMotor = high;
            }

            piblaster.setPwm(17, self.m_leftMotor);
        }
    }
};

NodeRob.prototype.initJoystick = function (i_callBack) {
    var self = this;
    var Joystick = require("joystick-logitech-f710");
    Joystick.create("/dev/input/js0", function (err, joystick) {
        if (err) {
            self.log('no joystick found', 0, 'red');
            return;
        }

        joystick.setMaximumAxesPosition(MAX_JOYSTICK);

        /****************
         * Motors
         ****************/
        joystick.on("stick:1:horizontal:right", function (position) {
            joyY = 0 - position;
            //self.log("STICK DOWN: " + position + ' joyY: ' + joyY, 3);
        });
        joystick.on("stick:1:horizontal:left", function (position) {
            joyY = position;
            //self.log("STICK UP: " + position + ' joyY: ' + joyY, 3);
        });
        joystick.on("stick:3:vertical:up", function (position) {
            joyX = position;
            //self.log("STICK LEFT: " + position + ' joyX: ' + joyX, 3);
        });
        joystick.on("stick:3:vertical:down", function (position) {
            joyX = 0 - position;
            //self.log("STICK RIGHT: " + position + ' joyX: ' + joyX, 3);
        });

        /****************
         *  cross
         ****************/
        joystick.on("button:crossup:press", function () {
            //log("A button:crossup:press", 3);
            self.m_servo2 = 100;
        });
        joystick.on("button:crossup:press:up", function () {
            //log("B button:crossup:press:up", 3);
            self.m_servo2 = 0;
        });
        joystick.on("button:crossdown:press", function () {
            //log("C button:crossdown:press", 3);
        });
        joystick.on("button:crossdown:press:up", function () {
            //log("D button:crossdown:press:up", 3);
        });
        joystick.on("button:crossleft:press", function () {
            //log("E button:crossleft:press", 3);
        });
        joystick.on("button:crossleft:press:up", function () {
            //log("F button:crossleft:press:up", 3);
        });
        joystick.on("button:crossright:press", function () {
            //log("G button:crossright:press", 3);
        });
        joystick.on("button:crossright:press:up", function () {
            //log("H button:crossright:press:up", 3);
        });


        joystick.on("button:a:press", function () {
            //log("a1", 3);
        });
        joystick.on("button:a:release", function () {
            //log("a2", 3);
        });
        joystick.on("button:a:release", function () {
            //log("a2", 3);
        });
        joystick.on("button:a:release", function () {
            //log("a2", 3);
        });
        joystick.on("stick:1:vertical:up", function (position) {
            //log("1: " + position, 3);
        });
        joystick.on("stick:1:vertical:down", function (position) {
            //log("2: " + position, 3);
        });
        joystick.on("stick:1:vertical:zero", function (position) {
            //log("3: " + position, 3);
        });
        joystick.on("stick:2:vertical:up", function (position) {
            self.m_servo1 = Math.round(position / 10) + 50;
            //log("7: " + position + ' ' + servo1);
        });
        joystick.on("stick:2:vertical:down", function (position) {
            /*self.m_servo1 = SERVO_CENTER_HAT - Math.round(position / 10);
            if (self.m_servo1 < 1)
               self.m_servo1 = 0;
            log("8: " + position + ' ' + servo0);*/
        });
        joystick.on("stick:2:vertical:zero", function (position) {
            //log("9: " + position, 3);
        });
        joystick.on("stick:2:horizontal:right", function (position) {
            /*self.m_servo0 = SERVO_CENTER_HAT - Math.round(position / 10);
            if (self.m_servo0 < 1)
                self.m_servo0 = 0;*/
            //log("10: postion" + position + ' servo ' + servo0);
        });
        joystick.on("stick:2:horizontal:left", function (position) {
            self.m_servo0 = Math.round(position / 10) + 50;
            //log("11: position " + position + ' servo ' + servo0);
        });
        joystick.on("stick:2:horizontal:zero", function (position) {
            //log("12: " + position, 3);
        });
        joystick.on("stick:3:horizontal:right", function (position) {
            //log("16: " + position, 3);
        });
        joystick.on("stick:3:horizontal:left", function (position) {
            //log("17: " + position, 3);
        });
        joystick.on("stick:3:horizontal:zero", function (position) {
            //log("18: " + position, 3);
        });
        joystick.on("stick:3:vertical:zero", function (position) {
            //log("A: " + position, 3);
        });
        joystick.on("stick:1:horizontal:zero", function (position) {
            //log("B: " + position, 3);
        });
        joystick.on("button:lb:press", function () {
            //self.m_sharpTurn = 1;
            //self._driveMotors(1, 1, 'sharpLeft');
        });
        joystick.on("button:lb:release", function () {
            //self.m_sharpTurn = 0;
            //self._driveMotors(0, 0, 'fwd');
        });
        joystick.on("button:rb:press", function () {
            //self.m_sharpTurn = 1;
            //self._driveMotors(1, 1, 'sharpRight');
        });
        joystick.on("button:rb:release", function () {
            //self.m_sharpTurn = 0;
            //self._driveMotors(0, 0, 'fwd');
        });
        joystick.on("button:ls:press", function () {
            //log("stop", 2);
            //self._driveMotors(0, 0, 'fwd');
        });
        joystick.on("button:ls:release", function () {
            //log("stop", 2);
            //self._driveMotors(0, 0, 'fwd');
        });

        i_callBack(joystick);
    });
};

/**
 Connect to python socket server
 @method initSocket
 **/
NodeRob.prototype.initSocket = function () {
    var self = this;
    if (self.m_serverConnect) {
        self.m_socket = new net.Socket();
        self.m_socket.connect(self.m_port, self.m_host, function () {
            self.log('Robot client connected', 0);
        });
        self.m_socket.on('data', function (data) {
            // receive input feedback from python server
            if (String(data).indexOf('LCD') > -1)
                self.emit(data)
        });
        self.m_socket.on('error', function (data) {
            self.log('no socket found ' + data, 0, 'red');
        });
        self.m_socket.on('close', function () {
            self.log('Connection closed', 0);
        });
        // catch cont-c
        //process.on('SIGINT', function(){
        //    socket.destroy();
        //    process.exit();
        //});
        return self.m_socket;
    }
};

NodeRob.prototype.initServos = function () {
    var self = this;
    for (var i = 0; i < TOTAL_SERVOS; i++) {
        var s = 'self.m_servo' + i + ' = SERVO_CENTER_HAT';
        eval(s);
    }
};

NodeRob.prototype.log = function (i_msg, i_level, i_color) {
    if (!i_color)
        i_color = 'yellow';
    var self = this;
    if (self.m_debug >= i_level) {
        console.log(i_msg[i_color])
    }
};

NodeRob.prototype.initLCD = function () {
    var self = this;
    var LCDHAT = require('adafruit-i2c-lcd').plate;
    lcd = new LCDHAT('/dev/i2c-1', 0x20);
    lcd.backlight(lcd.colors.GREEN);
};

NodeRob.prototype.initLCDButtons = function () {
    var self = this;
    if (!lcd)
        return;
    lcd.on('button_change', function (e) {
        var buttonEvent = 'LCD:BUTTON:' + lcd.buttonName(e);
        self.emit(buttonEvent);
    });
};

NodeRob.prototype.setLCD = function (msg1, msg2, lcdColor) {
    var self = this;
    if (!lcd)
        return;
    // LCDPLATE.colors = [OFF, RED, GREEN, BLUE, YELLOW, TEAL, VIOLET, WHITE, ON]
    lcd.clear();
    lcd.backlight(lcd.colors[lcdColor]);
    lcd.message(msg1 + '\n');
    lcd.message(msg2);
};

NodeRob.prototype.setValue = function (key, value) {
    var self = this;
    self[key] = value;
};

NodeRob.prototype.testGPIO = function () {
    var self = this;
    var led = new Gpio(20, 'out');
    var transistor = new Gpio(22, 'out');

    var button = new Gpio(21, 'in', 'both');
    //var button = new Gpio(21, 'in', 'falling', { persistentWatch: true, debounceTimeout: 100 });

    var a = 1;
    button.watch(function (err, value) {
        led.writeSync(value);
        console.log('Button being pressed ' + value);
        transistor.writeSync(value);
        //self.setLCD('Pressed ' + value + ' ' + a++, 'green');
    });
};

NodeRob.prototype.testServoBlaster = function () {
    var self = this;
    // run a server from 0 to 100% to 50% and back to 0
    piblaster.setPwm(4, 1);
    piblaster.setPwm(17, 0.01);
    setTimeout(function () {
        piblaster.setPwm(17, 0.24);
    }, 1000);
    setTimeout(function () {
        piblaster.setPwm(4, SERVO_CENTER_BLASTER);
    }, 2000);
    setTimeout(function () {
        piblaster.setPwm(4, 0.01);
    }, 3000);
};

NodeRob.prototype.testLCD = function () {
    var self = this;
    self.setLCD(Math.random(), 'hello\n', 'BLUE');
};

NodeRob.prototype.getValue = function (key) {
    var self = this;
    return self[key];
};

NodeRob.prototype.start = function () {
    var self = this;
    self.m_pollinghandle = setInterval(function () {
        //self.log('x ' + joyX + ' y ' + joyY, 1, 'white');
        //log('x ' + joyX + ' y ' + joyY, 1);
        self._differentialMotors();
        self._sendData();
    }, self.m_pollInterval);
};

exports.create = function (i_config) {
    return new NodeRob(i_config);
};

/*

 NodeRob.prototype._driveMotors = function (leftMotor, rightMotor, direction) {
 var self = this;

 if (direction == 'sharpLeft' || direction == 'sharpRight') {
 self.m_leftMotor = 255;
 self.m_rightMotor = 255;
 self.m_direction = direction;
 }

 if (self.m_sharpTurn)
 return;

 leftMotor = Math.abs(self._fixDec(leftMotor));
 rightMotor = Math.abs(self._fixDec(rightMotor));

 // if motor is very low, might as well reset to avoid noise
 leftMotor = leftMotor < 0.2 ? 0 : leftMotor;
 rightMotor = rightMotor < 0.2 ? 0 : rightMotor;

 // convert 0 (low) to 0.99 (high) into 0 - 255 for motor speed
 self.m_leftMotor = Math.round(self._perc(leftMotor, 255) * 100);
 self.m_rightMotor = Math.round(self._perc(rightMotor, 255) * 100);

 self.m_direction = direction;

 // console.log(leftMotor, rightMotor, direction);
 };
 */


// if motor is very low, might as well reset to avoid noise
//leftMotor = leftMotor < 0.2 ? 0 : leftMotor;
//rightMotor = rightMotor < 0.2 ? 0 : rightMotor;
// convert 0 (low) to 0.99 (high) into 0 - 25 for motor speed
// console.log(self.m_leftMotor + ' ' + self.m_rightMotor)